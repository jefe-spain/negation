[{"id":0,"title":"Constraints","content":"#\n\nNegation provides a set of built-in constraints for common validation scenarios.\nThese constraints are divided into two categories:\n\n 1. Basic Constraints: Simple constraints that can be used directly\n 2. Parameterized Constraints: Functions that return constraints with specific\n    parameters\n\n\nBasic Constraints#\n\n\nnotNull#\n\nEnsures a value is not null or undefined.\n\n\n\nIf the value is null or undefined, a NegationError will be thrown with the\nmessage \"Value must not be null or undefined\".\n\n\nnotEmpty#\n\nEnsures a string is not empty (after trimming whitespace).\n\n\n\nIf the string is empty, a NegationError will be thrown with the message \"String\nmust not be empty\".\n\n\nnotNegative#\n\nEnsures a number is not negative (less than 0).\n\n\n\nIf the number is negative, a NegationError will be thrown with the message\n\"Number must not be negative\".\n\n\nParameterized Constraints#\n\n\nnotLongerThan#\n\nCreates a constraint that ensures a string doesn't exceed a maximum length.\n\n\n\nIf the string is longer than the specified maximum length, a NegationError will\nbe thrown with the message \"String must not be longer than [maxLength]\ncharacters\".\n\n\nnotShorterThan#\n\nCreates a constraint that ensures a string isn't shorter than a minimum length.\n\n\n\nIf the string is shorter than the specified minimum length, a NegationError will\nbe thrown with the message \"String must not be shorter than [minLength]\ncharacters\".\n\n\nnotGreaterThan#\n\nCreates a constraint that ensures a number doesn't exceed a maximum value.\n\n\n\nIf the number is greater than the specified maximum value, a NegationError will\nbe thrown with the message \"Number must not be greater than [max]\".\n\n\nnotLessThan#\n\nCreates a constraint that ensures a number isn't less than a minimum value.\n\n\n\nIf the number is less than the specified minimum value, a NegationError will be\nthrown with the message \"Number must not be less than [min]\".\n\n\nCombining Constraints#\n\nConstraints can be combined to create more complex validation rules:\n\n\n\nThis will validate that the value is not null, not empty, and not longer than 10\ncharacters.","routePath":"/api/constraints","lang":"","toc":[{"text":"Basic Constraints","id":"basic-constraints","depth":2,"charIndex":299},{"text":"notNull","id":"notnull","depth":3,"charIndex":320},{"text":"notEmpty","id":"notempty","depth":3,"charIndex":499},{"text":"notNegative","id":"notnegative","depth":3,"charIndex":674},{"text":"Parameterized Constraints","id":"parameterized-constraints","depth":2,"charIndex":847},{"text":"notLongerThan","id":"notlongerthan","depth":3,"charIndex":876},{"text":"notShorterThan","id":"notshorterthan","depth":3,"charIndex":1137},{"text":"notGreaterThan","id":"notgreaterthan","depth":3,"charIndex":1405},{"text":"notLessThan","id":"notlessthan","depth":3,"charIndex":1650},{"text":"Combining Constraints","id":"combining-constraints","depth":2,"charIndex":1887}],"domain":"","frontmatter":{"title":"Constraints"},"version":""},{"id":1,"title":"Core Functions","content":"#\n\nNegation provides two main validation functions: negation for validating single\nvalues and negateObject for validating objects against a schema.\n\n\nnegation#\n\nThe negation function validates a single value against a list of constraints.\n\n\nSignature#\n\n\n\n\nParameters#\n\n * value: The value to validate\n * constraints: An array of constraints to validate against\n * options: Optional validation options\n   * mode: Validation mode, either 'throw' (default) or 'collect'\n\n\nReturn Value#\n\n * In 'throw' mode: Returns the validated value if all constraints pass,\n   otherwise throws a NegationError\n * In 'collect' mode: Returns an empty array if all constraints pass, otherwise\n   returns an array of NegationError objects\n\n\nExample#\n\n\n\n\nnegateObject#\n\nThe negateObject function validates an object against a schema of constraints.\n\n\nSignature#\n\n\n\n\nParameters#\n\n * obj: The object to validate\n * schema: A schema defining constraints for each property\n * options: Optional validation options\n   * mode: Validation mode, either 'throw' (default) or 'collect'\n\n\nReturn Value#\n\n * In 'throw' mode: Returns the validated object if all constraints pass,\n   otherwise throws a NegationError\n * In 'collect' mode: Returns an empty array if all constraints pass, otherwise\n   returns an array of NegationError objects\n\n\nExample#\n\n","routePath":"/api/core-functions","lang":"","toc":[{"text":"negation","id":"negation","depth":2,"charIndex":149},{"text":"Signature","id":"signature","depth":3,"charIndex":240},{"text":"Parameters","id":"parameters","depth":3,"charIndex":255},{"text":"Return Value","id":"return-value","depth":3,"charIndex":468},{"text":"Example","id":"example","depth":3,"charIndex":719},{"text":"negateObject","id":"negateobject","depth":2,"charIndex":732},{"text":"Signature","id":"signature-1","depth":3,"charIndex":828},{"text":"Parameters","id":"parameters-1","depth":3,"charIndex":843},{"text":"Return Value","id":"return-value-1","depth":3,"charIndex":1054},{"text":"Example","id":"example-1","depth":3,"charIndex":1306}],"domain":"","frontmatter":{"title":"Core Functions"},"version":""},{"id":2,"title":"API Reference","content":"#\n\nThis section provides detailed documentation for all the functions, types, and\nconstraints provided by Negation.\n\n\nOverview#\n\nNegation provides two main validation functions:\n\n * negation: For validating single values\n * negateObject: For validating objects against a schema\n\nIt also provides a set of built-in constraints:\n\n\nBasic Constraints#\n\n * notNull: Ensures value is not null or undefined\n * notEmpty: Ensures string is not empty\n * notNegative: Ensures number is not negative\n\n\nParameterized Constraints#\n\n * notLongerThan: Ensures string doesn't exceed maximum length\n * notShorterThan: Ensures string isn't shorter than minimum length\n * notGreaterThan: Ensures number doesn't exceed maximum value\n * notLessThan: Ensures number isn't less than minimum value\n\n\nType Definitions#\n\nNegation provides TypeScript type definitions for all its functions and\nconstraints. See the Types section for details.\n\n\nError Handling#\n\nNegation uses the NegationError class for validation errors, which includes:\n\n * path: The path to the invalid value (empty array for single values)\n * message: Human-readable error message\n * constraint: The constraint that failed\n\n\nNext Steps#\n\n * Check out the Core Functions for detailed documentation of the main\n   validation functions\n * See the Constraints section for documentation of all built-in constraints\n * Visit the Types section for TypeScript type definitions","routePath":"/api/","lang":"","toc":[{"text":"Overview","id":"overview","depth":2,"charIndex":117},{"text":"Basic Constraints","id":"basic-constraints","depth":3,"charIndex":328},{"text":"Parameterized Constraints","id":"parameterized-constraints","depth":3,"charIndex":489},{"text":"Type Definitions","id":"type-definitions","depth":2,"charIndex":774},{"text":"Error Handling","id":"error-handling","depth":2,"charIndex":915},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":1166}],"domain":"","frontmatter":{"title":"API Reference"},"version":""},{"id":3,"title":"Types","content":"#\n\nNegation provides TypeScript type definitions for all its functions and\nconstraints. This page documents the main types used in the library.\n\n\nValidationMode#\n\nDefines the validation mode:\n\n\n\n * 'throw': Throws a NegationError on the first validation failure (default)\n * 'collect': Collects all validation errors and returns them as an array\n\n\nValidationOptions#\n\nOptions for validation functions:\n\n\n\n\nNegationError#\n\nError class for validation errors:\n\n\n\nProperties:\n\n * path: The path to the invalid value (empty array for single values)\n * message: Human-readable error message\n * constraint: The constraint that failed\n\n\nConstraint#\n\nType definition for constraints:\n\n\n\nA constraint can be either:\n\n * A function that takes a value and a path and throws a NegationError if the\n   value is invalid\n * An object with a validate method and a constraint string\n\n\nSchema#\n\nType definition for validation schemas:\n\n\n\nA schema is an object where each key corresponds to a property in the object\nbeing validated, and the value is an array of constraints for that property.","routePath":"/api/types","lang":"","toc":[{"text":"ValidationMode","id":"validationmode","depth":2,"charIndex":145},{"text":"ValidationOptions","id":"validationoptions","depth":2,"charIndex":347},{"text":"NegationError","id":"negationerror","depth":2,"charIndex":405},{"text":"Constraint","id":"constraint","depth":2,"charIndex":628},{"text":"Schema","id":"schema","depth":2,"charIndex":866}],"domain":"","frontmatter":{"title":"Types"},"version":""},{"id":4,"title":"Examples","content":"#\n\nThis section provides real-world examples of how to use Negation in your\napplications. These examples demonstrate common validation scenarios and best\npractices.\n\n\nOverview#\n\n * Form Validation: Learn how to validate form inputs using Negation\n * API Data Validation: See how to validate API request and response data\n\nEach example includes complete code samples that you can copy and adapt for your\nown projects.","routePath":"/examples/","lang":"","toc":[{"text":"Overview","id":"overview","depth":2,"charIndex":166}],"domain":"","frontmatter":{"title":"Examples"},"version":""},{"id":5,"title":"Core Concepts","content":"#\n\nNegation is built around the concept of \"negative space programming\" for\nvalidation. This page explains the key concepts and philosophy behind the\nlibrary.\n\n\nNegative Space Programming#\n\nIn traditional validation libraries, you define what data should be:\n\n * \"This must be a string\"\n * \"This must be a number greater than 0\"\n * \"This must match this pattern\"\n\nNegation flips this paradigm by focusing on what data should not be:\n\n * \"This must not be null\"\n * \"This must not be empty\"\n * \"This must not be negative\"\n\nThis approach often leads to more intuitive and readable validation rules that\nbetter match how we think about validation in natural language.\n\n\nWhy Negative Validation?#\n\nThere are several advantages to the negative validation approach:\n\n 1. More Intuitive: Constraints like \"must not be empty\" are often more\n    intuitive than \"must be a non-empty string\"\n 2. Better Edge Case Handling: By explicitly defining what must not occur,\n    you're less likely to miss edge cases\n 3. More Concise: Negative constraints often lead to more concise code\n 4. Better Error Messages: Error messages like \"String must not be empty\" are\n    often more helpful than \"String must be valid\"\n\n\nConstraints#\n\nIn Negation, validation rules are defined as constraints - functions that check\nif a value violates a specific rule. If the rule is violated, the constraint\nthrows a NegationError.\n\nConstraints come in two forms:\n\n 1. Direct Constraints: Simple constraints like notNull and notEmpty that can be\n    used directly\n 2. Parameterized Constraints: Functions that return constraints, like\n    notLongerThan(10) and notLessThan(5)\n\n\nValidation Modes#\n\nNegation supports two validation modes:\n\n 1. Throw Mode (default): Throws a NegationError on the first validation failure\n 2. Collect Mode: Collects all validation errors and returns them as an array\n\n\nPath Tracking#\n\nWhen validating objects, Negation tracks the path to each invalid field. This\nmakes it easy to identify which field failed validation and why.\n\nFor example, if a user's email is invalid, the error will include the path\n['email'] to help you identify the problematic field.\n\n\nType Safety#\n\nNegation is built with TypeScript and provides complete type safety. Constraints\nare typed to ensure they're only used with compatible value types (e.g.,\nnotEmpty can only be used with strings).","routePath":"/guide/core-concepts","lang":"","toc":[{"text":"Negative Space Programming","id":"negative-space-programming","depth":2,"charIndex":160},{"text":"Why Negative Validation?","id":"why-negative-validation","depth":2,"charIndex":665},{"text":"Constraints","id":"constraints","depth":2,"charIndex":1198},{"text":"Validation Modes","id":"validation-modes","depth":2,"charIndex":1639},{"text":"Path Tracking","id":"path-tracking","depth":2,"charIndex":1860},{"text":"Type Safety","id":"type-safety","depth":2,"charIndex":2151}],"domain":"","frontmatter":{"title":"Core Concepts"},"version":""},{"id":6,"title":"Getting Started","content":"#\n\nThis guide will help you get started with Negation in your project.\n\n\nInstallation#\n\nNegation is available as an npm package. You can install it using npm or yarn:\n\n\n\nNOTE\n\nNegation is currently in development (v0.0.1). The package will be published to\nnpm soon.\n\n\nBasic Usage#\n\nHere's a simple example of how to use Negation for validating a string:\n\n\n\n\nValidating Objects#\n\nNegation can also validate objects against a schema:\n\n\n\n\nCollecting All Errors#\n\nBy default, Negation throws an error on the first validation failure. If you\nwant to collect all errors instead, you can use the collect mode:\n\n\n\n\nNext Steps#\n\nNow that you understand the basics, check out:\n\n * Core Concepts to learn more about Negation's philosophy\n * API Reference for detailed documentation of all functions and constraints\n * Examples for real-world usage examples","routePath":"/guide/getting-started","lang":"","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":72},{"text":"Basic Usage","id":"basic-usage","depth":2,"charIndex":267},{"text":"Validating Objects","id":"validating-objects","depth":2,"charIndex":357},{"text":"Collecting All Errors","id":"collecting-all-errors","depth":2,"charIndex":435},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":606}],"domain":"","frontmatter":{"title":"Getting Started"},"version":""},{"id":7,"title":"Introduction","content":"#\n\nNegation is a lightweight TypeScript validation library that takes a unique\napproach to validation through \"negative space programming.\" Instead of defining\nwhat data should be, Negation focuses on what data should not be.\n\n\nWhy Negation?#\n\nTraditional validation libraries focus on positive assertions: \"this must be a\nstring,\" \"this must be a number,\" etc. While this approach works, it often leads\nto verbose code and can miss edge cases.\n\nNegation flips this paradigm by focusing on constraints - what data must not be:\n\n * A value must not be null\n * A string must not be empty\n * A number must not be negative\n\nThis approach often leads to more intuitive validation rules that better match\nhow we think about validation in natural language.\n\n\nKey Features#\n\n * Intuitive API: Define validation rules in terms of what data should not be\n * Type Safety: Built with TypeScript for complete type safety\n * Lightweight: Minimal bundle size with no dependencies\n * Flexible Error Handling: Choose between throwing on first error or collecting\n   all errors\n * Path Tracking: Errors include paths to invalid fields for clear debugging\n * Composable Rules: Easily combine multiple constraints\n\n\nWhen to Use Negation#\n\nNegation is ideal for:\n\n * Form validation in web applications\n * API request/response validation\n * Data validation in TypeScript/JavaScript applications\n * Anywhere you need lightweight, type-safe validation\n\nReady to get started? Check out the Getting Started guide.","routePath":"/guide/","lang":"","toc":[{"text":"Why Negation?","id":"why-negation","depth":2,"charIndex":227},{"text":"Key Features","id":"key-features","depth":2,"charIndex":751},{"text":"When to Use Negation","id":"when-to-use-negation","depth":2,"charIndex":1195}],"domain":"","frontmatter":{"title":"Introduction"},"version":""}]